======================================[0726]======================================

교과목
* 데이터 입출력 구현
   - 데이터베이스/고급자바 -> mybatis
   - JSP/Servlet: 게시판 과제

* 서버 프로그램 구현
   - Spring framework: 게시판 과제
   - Spring batch: 배치 과제

* 애플리케이션 배포
   - virtual box, raspberry를 이용한 서버 구축/배포: 배포 스크립트 작성 과제

* 애플리케이션 테스트 수행
   - 교과 내용 진행시 테스트 병행: 게시판 과제시 병행

* 애플리케이션 통합 --> 4가지 이후
   - 애플리케이션 테스트
   - Spring boot
   - 최종프로젝트 설계

* 같은 기능을 다른 환경으로
   - spring -> spring Boot -> node.js
   - maria db -> firebase
   - jsp -> thymeleaf -> pug

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

[서버환경]
* 화면 / 비지니스 로직 / 데이터베이스 <-- 3가지

* Client / Server Architecture(1-tier)
   - 한 시스템에 모두 있는 환경
   - 확장 어려움

* Client / Server Architecture(2-tier)
   - 전용 Client 프로그램 - 속도가 빠르다(병원 진료, 차트 프로그램)
   - DB만 공유하고 UI, business 로직은 Client 프로그램에 탑재
   - 클라이언트간 통신이 힘듬 / 보안문제

* Client / Server Architecture(3-tier)
   - 전용 Client 프로그램 - 속도가 빠르다(온라인 게임)
   - 로직이 서버에 있음
   - 클라이언트가 요청 시 서버에서 로직을 전송
   - 클라이언트프로그램의 배포가 문제

* Web Architecture
   - 브라우저 기능에 의존, 제한적인 UI(Flex, flash)
   - 브라우저 기능을 벗어나는 추가기능 사용시 호환성 / 보안문제(Active x)
   - 모든 브라우저가 동일한 기능을 제공하지 않음(브라우저별 호환문제)
   - 같은 브라우저의 버전별 호환 문제
   - Web Server(클라이언트의 요청으로 결과를 전송, 아파치서버)
     정적 자원 처리에 최적화(html, css, js, image)
   - Web Application Server(톰캣)
     동적 컨텐츠를 생성하여 Web Server에 전달

* 사용하게 될 애플리케이션: sping JUnit git maven(라이브러리가져오기)

[형상관리]
   - 프로젝트나 제품의 전체 수명주기에 걸쳐 시스템이나 소프트웨어의 변경을
     추적하고 상태를 유지
   - 시스템이 개발 완료된 이후, 유지보수되는 동안 계속적으로 사용

   - 아파치 : Hadoop, HTTP, POI, Maven

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

[Maven 설치] --> http://maven.apache.org/

* 사이트 접속 후 Download -> Binary zip archive다운로드(apache-maven-3.6.1-bin.zip)

* 압축풀기 후 폴더이름 'maven'으로 바꿔주기

* 학원컴 경로: E:\B_Util\6.maven\maven

* 해당 폴더의 bin폴더에서 cmd를 키고 'mvn -version' --> 버전이 나옴

* 다른 폴더에선 'mvn -version'이 안되므로 환경변수 설정을 해준다.

* 환경변수 새로설정
   - 이름: M2_HOME
   - 경로: E:\B_Util\6.maven\maven

* 환경변수의 Path에서 새로 만들기
   - %M2_HOME%\bin

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

[이클립스 환경설정]

ㅁ 경로: E:\A_TeachingMaterial\7.JspSpring\workspace

ㅁ 환경설정 - Java - Code Style - Code templete - comments: types
/**
* ${file_name}
*
* @author ${user}
* @version 1.0
* @see
*
* <pre>
* << 개정이력(Modification Information) >>
*
* 수정자 수정내용
* ------ ------------------------
* ${user} 최초 생성
*
* </pre>
*/

ㅁ 환경설정 - Java - Code Style - Code templete - comments: methods / Overridng methods
/**
* Method : ${enclosing_method}
* 작성자 : ${user}
* 변경이력 :
* ${tags}
* Method 설명 :
*/

ㅁ test comments --> 환경설정 - Java - Editor - Templates - New
name: gwt
Pattern: 
/***Given***/
${cursor}

/***When***/


/***Then***/

ㅁutf-8 설정
   - encoding검색해서 utf-8로 설정

ㅁ 자주 사용 할 Perspective: JavaEE, debug
   - Perspective간 이동하는 단축키 Ctrl + F8 --> F8 or Shift + F8

ㅁ view 이동: Ctrl + F7
   - Editor로 바로 이동: F12


ㅁ Getter/Setter 단축키
   - 윈도우 - 프리퍼런스 - keys - type filter text에 getter 검색 -
     Generate Getters and Setters(methods) 선택 -> Binding을 Ctrl + Alt + S로 설정
   - 혹은, 우측상단 Quick Access(Ctrl + 3) -> Getters 검색 / toString 검색

ㅁ 디버깅
   - 브레이크포인트: 줄넘버에 더블클릭
   - Variables: 변수들
      > 빨간네모: private를 의미
   - Expressions 자주 사용함, --> 코드를 실행할 수 있는 공간
   - Resume(F8): 다음 브레이크 포인트까지 이동
   - Step Into(F5): 메소드 호출이 있을 때 안으로 들어감
   - Step Return(F7): 메소드 안에서 바로 나가기
   - Step Over(F6): 메소드를 실행하지 않고 다음으로 넘어감
   - Ctrl + F2: 프로그램(디버그) 종료

ㅁ 단축키
   - Alt + Shift + J: 주석
   - Ctrl + M: view 화면 최대화 <-> 최소화
   - Ctrl + F8: Perspective 이동 --> 창이 뜬 뒤 F8은 밑으로, Shift + F8은 위로
   - Ctrl + F7: view 이동 --> 창이 뜬 뒤 F8은 밑으로, Shift + F8은 위로
   - F12: editor view로 이동
   - F3: 레퍼런스 참조
   - F4: 계층구조
   - Alt + Left(Right) -> 이전(뒤) view로 이동
   - Ctrl + PageUp(PageDown) -> view 왼쪽(오른쪽)
   - Alt + Shift + R: 이름 변경(관련된 것 모두 변경) --> 변수명은 일일히 해줘야
   - Alt + Shift + A: 세로 편집 --> Shift로 영역 설정
   - Ctrl + 3: Quick Access

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

[이론]

ㅁ WAS(웹 어플리케이션 서버 방식)
   - servlet/jsp는 thread방식으로 실행 -> 동시처리 성능이 우수
   - servlet/jsp는 main함수를 통해 실행하지 않는다.





======================================[0729]======================================

[Git을 통해 프로젝트 Import]

ㅁ git 설치(https://git-scm.com/ -> 2.22.0 다운로드 -> 계속 Next로 설치)
   -> git은 자동을 환경변수 설정을 해준다.(cmd> git --version)

ㅁ 경로이동 cd e:
   cd~cd~ --> 결과 /e/A_TeachingMaterial/7.JspSpring/workspace

ㅁ 깃헙 복사
   git clone https://github.com/jinwoolee/jsp

ㅁ 지우기.. rm -rf jsp (이클립스에서 하기로 함)

ㅁ import -> Projects from Git -> Clone URI -> URI: https://github.com/jinwoolee/jsp
   -> javaServer선택 -> next -> Import as general project 선택 -> 
   프로젝트이름 jsp

ㅁ 프로젝트 우클릭 - Configure - Convert to Maven Project

ㅁ 알트 F5 - OK

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

ㅁ default port
   - http: 80
   - https: 443

ㅁ servlet: 자바의 웹 개발 표준 스펙, 스펙에 따라 만들어진 소스.
            멀티 쓰레드로 실행. 자바 코드 안에 html

ㅁ Jsp: 실행 코드 방식인(java) servlet의 스크립트 방식의 표준 스텍
        jsp는 실행시 servlet으로 변환되어 실행. html안에 자바 코드

ㅁ Web Container: 표준 규약에 따라 구현된 웹 어플리케이션을 관리하고 실행할 수
                  있는 소프트웨어(tomcat, resin, jboss 등)

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

[servlet]

ㅁ 위자드 - Maven Project - Create a simple project 체크 후 Next -
   Group Id: 해당 프로젝트를 진행하는 회사를 대표할 수 있는 정보
             (주로 url 역순) ==> kr.or.ddit
   Artifact Id: 해당 회사에서 진행하는 프로젝트 이름  ==> jsp / spring
   Version: 프로젝트의 버전 ==> 기본값
   Packaging: 해당 프로젝트를 패키징할 때 어떤 파일로 패키징 할지 ==> war
              ( jar, java 아카이브, war: web 아카이브(img, html, css, jsp) )
   * 위 4가지만 적으면 됨   

   * web.xml is missing and <failOnMissingWebXml> is set to true
     생성하고 나면 위와 같은 에러가 발생
   * WEB-INF안에는 Classes안에 class, lib안에 lib파일, XML web.xml으로 3가지는
     규격에 맞춰야 한다.
   * web.xml이 존재하지 않으므로 Java EE Tools - Generate Deployment 

   * jdk 설정 - jsp/pom.xml의 <packaging> 밑에 아래 내용을 써준다.
	<build>
	  	<plugins>
	  		<plugin>
	  			<!--  maven compiler plugin -->
	  			<artifactId>maven-compiler-plugin</artifactId>
	  			<configuration>
	  				<source>1.8</source>
	  				<target>1.8</target>
	  			</configuration>
	  		</plugin>
	  	</plugins>
	  </build>

   * Ctrl + Shift + R: Resource찾기(web)
     2번째 줄 맨 뒤.. web-app_3_0.xsd" version="3.0"> .. 3.0으로 바꿔줌

   * webapp에 index.html을 만들어줌

   * view - Servers에 new 하던지, 위자드에서 server.. - Tomcat v7.0 Server 선택
     - host name은 변경x(localhost), server name은 변경가능(jsp server로..) - 
     경로: E:\B_Util\5.ApacheTomcat\apache-tomcat-7.0.73 후 next - 오른쪽으로 add
     - finish

   * 윈도우 - 프리퍼런스 - runtime 검색 - Server의 Runtime Environments - add
     - 톰캣7.0

   * Servers 패키지에서 server.xml(Ctrl + Shift + r도 가능) - 65번째 줄 포트번호
     8081로 변경

   * 혹은 Server view에서 서버 더블클릭해서 ports의 HTTP/1.1을 8081로 변경

   * 서버 실행(Alt + Shift + R)

   * http://localhost:8081/jsp/index.html 입력하면 들어가짐.
     or http://localhost:8081/jsp/
 
   * 위 주소를 바꾸고 싶으면 jsp server의 Modules탭에 edit를 해서
     Path를 /로 바꿔준다.
     ==> http://localhost:8081만 쳐도 접속 가능해짐
     ==> web.xml의 welcome-file이 순차적으로 실행되서 index.html이 실행됨

   * 톰캣 설치 폴더.. E:\B_Util\5.ApacheTomcat\apache-tomcat-7.0.73
     - conf 폴더의 server.xml과 web.xml을 복사해서 사용함
     - lib폴더: 표준 스펙에 대한.. 구현체
     - logs: 서버가 실행되거나 종료하거나 에러등이 발생했을 때 로그를 남기는 곳
     - temp: 임시 영역
     - webapps: 내부 폴더 하나 하나가 웹어플리케이션

   * 위 폴더의 conf에 server.xml을 실행해서 8080검색, 값을 8081로 변경

   * 서버뷰 - 서버더블클릭 - open launch configuration 클릭 - arguments탭 - 
     VM arguments: 에 있는
     -Dwtp.deploy="E:\A_TeachingMaterial\7.JspSpring\workspace\.metadata\.plugins\
                   org.eclipse.wst.server.core\tmp0\wtpwebapps" 
     ==> 이 경로로 자동으로 서버의 내용을 바꿔준다?..

ㅁ 메이븐 배우는 이유.. 두 개의 jar파일이 한 jar파일을 참조하려고 하면 안되서..

ㅁ maven source folder 기본 구조
   - src/main/java : product 코드(운영코드)
   - src/main/resources : 운영환경에서 필요한 설정파일들(java 파일이 아닌 것들)
   - src/test/java : 개발 진행시 사용하는 테스트 코드
                     (운영환경에서는 필요 없는 코드들)
   - src/test/resources : 개발 진행시 사용하는 테스트 코드의 설정 파일들
                          (운영환경에서는 필요 없는 설정 파일들)

ㅁ servlet
   - src/main/java에 kr.or.ddit.servlet패키지 생성
   - HelloServlet클래스 생성
     * J2EE 기반의 웹 어플리케이션 개발 시 main method를 통해 실행하지 않는다.
     * 우리가 작성한 웹 어플리케이션(war)을 was(tomcat)의 webapps 폴더 밑에
       이동을 시켜주면 서버가 기동할 때 해당 어플리케이션을 자동으로 로딩한다.
     * 웹 어플리케이션의 폴더명이 context path가 된다.
     *** 서버 설정에 의해서 폴더명과 다른 context path를 부여하는게 가능
         (하지만 우리는 서버 엔지니어가 아니기 때문에 해당 부분까지는 가지 않는다.)
     * 특정 url을 호출하면, url을 처리해줄 수 있는 servlet을 호출하여 응답을 생성한다.
     * servlet 생성방법
        1. class를 생성
        2. HttpServlet 클래스를 상속을 한다(J2EE spec을 따른다)
	3. doGet, doPost 메소드를 오버라이딩 한다.
        4. 어떤 url을 해당 서블릿에서 처리할 지 매핑
           (web.xml, servlet 3.0이후부터 servlet class 어노테이션으로 설정)

        ==> 2.를 하려면 servlet.jar가 필요한데 tomcat폴더에 있다..
            이 파일을 고급자바시간때처럼 build path하지 않음(이클립스를 벗어나면 이용 못하므로)
        ==> pom.xml에서 설정하면 된다. 위에서 build를 적었던 곳 바로 밑에 아래 내용 작성
	
	<!-- 프로젝트에서 사용하는 의존성 관리(라이브러리) -->
	<!-- https://mvnrepository.com/ 에서 주로 사용 -->
	<dependencies>
  		<!-- servlet api -->
		<dependency>
			<groupId>javax.servlet</groupId>
			<artifactId>javax.servlet-api</artifactId>
			<version>3.0.1</version>
			<scope>provided</scope>
		</dependency>
	</dependencies>   

	==> 3. 알트쉬프트S Override/Implement Methods클릭, doGet오버라이드
	@Override
	protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		 resp.setContentType("text/html");
		 
		 PrintWriter pw = resp.getWriter();
		 pw.write("<html>");
		 pw.write("	<head>");
		 pw.write("		<title>helloServlet</title>");
		 pw.write("	</head>");
		 pw.write("	<body>");
		 pw.write("		<h1>hello, world</h1>");
		 pw.write("	</body>");
		 pw.write("</html>");
	}

	==> 4. web.xml에 (src/main/webapp/WEB-INF) 매핑
	  <servlet>
	  	<!-- 개발자가 붙여주는 서블릿 이름(별칭) -->
	  	<servlet-name>helloWorld</servlet-name>
	  	<!-- 서블릿의 풀 네임(패키지+클래스명) -->	
	  	<servlet-class>kr.or.ddit.servlet.HelloServlet</servlet-class> 
	  </servlet>
	  <servlet-mapping>
	  	<servlet-name>helloWorld</servlet-name> <!-- 위 별칭과 이름이 같아야 함 -->
	  	<url-pattern>/helloWorld</url-pattern>
	  </servlet-mapping>
	
	==> http://localhost:8081/helloWorld에 접속하면 뜸





======================================[0730]======================================

[복습]

1. 위자드 - simple project 체크 - kr.or.ddit / jspTest / war - finish

2. 프로젝트 우클릭 - Java EE Tools - Generate Deployment Discriptor Stub 클릭

3. pom.xml에 아래 사항 적어주기
	<build>
	  	<plugins>
	  		<plugin>
	  			<artifactId>maven-compiler-plugin</artifactId>
	  			<configuration>
	  				<source>1.8</source>
	  				<target>1.8</target>
	  			</configuration>
	  		</plugin>
	  	</plugins>
	</build>

4. Alt + F5 --> 업데이트

5. src/main/java에 패키지 만들기 --> kr.or.kr.servlet

6. class 만들기 --> HelloServlet

7. extends HttpServlet하기 --> 에러발생
   * 아래와 같은 내용 pom.xml에 추가하기(ctrl + shift + r)
	<dependencies>
	  	<!-- servlet api -->
		<dependency>
			<groupId>javax.servlet</groupId>
			<artifactId>javax.servlet-api</artifactId>
			<version>3.0.1</version>
			<scope>provided</scope>
		</dependency>
	</dependencies>

8. Alt + Shift + S --> doGet Override하기 --> 내용 2줄 지우기

9. 내용 작성하기.
	PrintWriter pw = resp.getWriter();
	pw.write("test");

10. url을 해당 서블릿에서 처리할지 매핑한다. (web.xml 방식으로)
--> <servlet>과 <servlet-mapping>을 만들고
	각각 안에 아래와 같이 만들어 준다.
-->     <servlet>
	  	<servlet-name>helloServlet</servlet-name>
  		<servlet-class>kr.or.ddit.servlet.HelloServlet</servlet-class>
	</servlet>
	<servlet-mapping>
	  	<servlet-name>helloServlet</servlet-name>
  		<url-pattern>/hello</url-pattern>
	</servlet-mapping>

11. 서버생성 -> server name 적기 -> 프로젝트 선택 -> finish

12. 서버의 Overview탭에 HTTP를 8092로 수정

13. 서버의 Modules탭 -> Path를 /로 수정

14. 클래스 파일에 doGet에 작성.
	resp.setContentType("text/html; charset=utf-8");
		 
	PrintWriter pw = resp.getWriter();
	pw.write("<html>");
	pw.write("	<head>");
	pw.write("		<title>helloServlet</title>");
	pw.write("	</head>");
	pw.write("	<body>");
	pw.write("		<h1>hello, world 한글 테스트</h1>");
	pw.write("	</body>");
	pw.write("</html>");
   * 한글이 안 나오면 charset=utf-8를 적어주면 된다.
   * pw.println(""); 으로 쓰면 줄바꿈을 해줌(페이지 소스보기에서)

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

[이론]

ㅁ init() -> 서블릿(톰캣) -> destory()
                 :
		 :
         service() -> doXXX()

ㅁ init()은 최초 1회만 실행됨(사용자가 URL에 처음 접속했을 때)
   --> 이후 service()<doXXX()>메서드를 호출 함

ㅁ 대다수는 URL을 입력했을 때 GET방식(단순요청)으로 간다.
	--> 언젠가? POST방식(form을 통한 입력/저장, pw를 암호화할 때)으로 바꿀 수 있다.

ㅁ 2xx: 정상
   4xx: 클라이언트 오류 (주소 잘못입력 등..)
   5xx: 개발자 오류

ㅁ Servlet -> JSP.. JSP가 나온 이유
   - url-mapping 
   - out.write() --> 자바안에 html
   - 협업의 어려움

[연습문제]

ㅁ localhost:8081/TimesTablesServlet에 구구단 출력하기
   - jsp프로젝트에 TimesTablesServlet.java

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

[Logback] - - log 라이브러리

ㅁ 공식사이트
   - logback.qos.ch

ㅁ 필요한 이유 
   - 개발 할때는 상세한 로깅 필요
   - 운영 환경에서는 에러 메시지만 필요

ㅁ dependency
	<!-- logback api -->
	<dependency>
		<groupId>ch.qos.logback</groupId>
		<artifactId>logback-classic</artifactId>
		<version>1.2.3</version>
	</dependency>

ㅁ 위치 - src/main/resources
   - 위 경로에 logback.xml파일을 만들고 아래 내용을 적어준다
	<configuration>
		<!-- appender(어디에 로그를 출력할지), layout(어떤 형식으로 출력할지), logger(로그 출력담당, 계층구조를 가짐) -->
		<appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
			<!-- encoders are assigned the type ch.qos.logback.classic.encoder.PatternLayoutEncoder 
				by default -->
			<encoder>
				<pattern>%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n <!-- 레이아웃 -->
				</pattern>
			</encoder>
		</appender>
	
		<root level="debug"> <!-- 기본 로거(root) -->
			<appender-ref ref="STDOUT" />
		</root>
	</configuration>

ㅁ 로거 환경설정
   - 환경설정 - Java - Editor - Templates - New
   - 이름 : logger
   - 내용 : ${:import(org.slf4j.Logger,org.slf4j.LoggerFactory)}private static final Logger logger = LoggerFactory.getLogger(${enclosing_type}.class);

ㅁ 사용법
   - 위 경로로 다 설정 했다면 클래스에 아래 내용을 기입한다.
	
	// TimesTablesServlet.class: 현재 클래스의 정보가 저장됨
	private Logger logger = LoggerFactory.getLogger(TimesTablesServlet.class);
	--> logger 치고 ctrl + space 가능
	
	doget안에 logger.debug("TimesTablesServlet doGet()");를 적는다.

ㅁ Logging level
   - trace: debug보다 상세한 정보 출력
   - debug: 프로그램을 디버깅 하기 위한 정보를 출력
   - info: 상태변경과 같은 정보성 메시지 출력
   - warn: 향후 시스템에 문제가 발생할 가능성이 있는 메시지 출력
   - error: 에러가 발생했을 때(ex: catch)

ㅁ 로거 출력할 때 주의할 점
   doGet {
	String method = req.getMethod();
	// 아래처럼 하면 안됨
	logger.debug("debug TimesTablesServlet doGet()" + method);
	// 아래처럼 해야 됨
	logger.debug("debug TimesTablesServlet doGet() {} {}", method, method + "test");
   }





======================================[0731]======================================

[형상관리]

ㅁ Git/Github의 특징
   - 무료이고 빠르다
   - 분산 버전 관리 시스템
   - 네트워크가 단절되어도 개인 저장소에 commit 가능(리모트 사이트에는 불가)
   - 개인PC --> Git  /  공유사이트 --> Github

ㅁ Git 설정 --> git bash에서

   - 삭제
      > rm -rf ~~~

   - 현재 경로
      > pwd

   - git config 조회
      > git config -l // (= git config --list ; 롱옵션)

   - 사용자 환경 설정
      > git config --global user.name "jms"
      > git config --global user.email "mingsoo0807@gmail.com"

   * /e/A_TeachingMaterial/7.JspSpring --> mkdir git
   * /e/A_TeachingMaterial/7.JspSpring/git --> mkdir user1
   * /e/A_TeachingMaterial/7.JspSpring/git/user1 --> git init // 현재 경로를 기본경로로
     ==> 해당 경로에 .git 폴더가 생김(숨긴상태) 
     ==> 해당 폴더를 지우면 작업하던 git 내용이 없어짐.(삭제 가능)

   - git status --> 추가되지 않았다고 빨간 글씨로 나옴

   - git add UserVo.java --> 파일 한개가 add됨   
   - git add *.java --> .java인 파일들이 add됨   ==> 녹색으로 바뀜
   - git add * --> 파일 전체가 add됨

   - git commit -m 'userVo' --> 파일 전체가 commit 됨, 'userVo'라는 설명이 달림
			==> 사라짐

   -------- 현재까지 내PC에 저장함.

   - github.com에 접속
   - new repository 생성
      > Repository name: git
      > Description: 설명(옵션)
      > Public / Private
     --> Create repository 클릭
     ==> https://github.com/gguksoon/git.git으로 주소가 생성됨
           ==> https://github.com/gguksoon/git로 접속해도 됨

  ------------------------------ repository 생성 끝

   - bash로 가서 연결
       > git remote add origin https://github.com/gguksoon/git.git (Shift + Insert)

   - 확인
       > git remote -v

   - push
       > git push -u origin master   <-- master 브랜치에 입력해라..
					(-u옵션은 한번 입력한 뒤 앞으로 
 					  git push만 해도 -u 뒤에 문장이 수행됨)

   - .git 위치로 이동
      > git clone https://github.com/gguksoon/git   <-- git이 생성
      > git clone https://github.com/gguksoon/git user2  <-- user2에 생성

   --> user2에서 작업을하고 add, commit, push를 한 다음

   --> user1에서 확인하면 변경사항이 없음

   --> git pull을 해주면 된다.

  ------------------------------ 끝
  
  -------------------------------- 다른 사용자가 같은 파일을 수정할 때... 시작

  - git log --> 커밋 이력이 나옴

  - 수정을 시작하면 커밋된 사항이 나오고 충돌난 부분이 주석으로 나타남
  - 고치고 다시 add, commit, push하면 됨.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

[Eclipse + Git]
ㅁ 프로젝트 생성 -> kr.or.ddit / git / war -> 1.8 컴파일러 등록 -> 
  프로젝트 우클릭 -> Team - Share Project 클릭 - Git 선택 후 Next
  -> Use or create ... 선택 -> git(프로젝트명) 선택 -> Create Repository 클릭
  -> finish

ㅁ show view에 other -> git repositories, git staging 선택
   - Git Staging에서 Unstaged Changes의 항목을 선택해서
     Staged Changes로 드래그해 놓고, Commit Message를 적는다.
    * .classpath, .project를 빼고 커밋한다.
          --> .gitignore파일에 등록가능(Ctrl + Shift + R)
		==> /target/
		    .classpath
		    .settings	   ==> 3가지를 등록..
		    .project	
    * 위 사항은 커밋하기 전에 적어야 된다. --> ★★★★★
      (처음에 하지 않으면 적용이 안된다. 다시 작업해야됨.) 
    * 위 사항이 번거로울 수 있기에 자동으로 해주는 방법이 있다.
      ==> gitignore.io ==> eclipse, maven 선택 후 생성
         ==> 생성된 내용을 .gitignore에 덮어쓰기

       --> git staging 에서 모든 파일 commit and push



   - remote 연결
      <push 설정>
     > git repositories탭 -> git 열기 -> Remotes가 안열리면 연결안된 상태
      -> 우클릭 Create Remote -> 이름 그대로(origin), push 후 create 
       테스트용 repository 생성(github.com에서), 이름은 eGit.. ->
       주소 복사하여  -> change클릭 아마 붙여쓰기 될거임
       -> user, password에는 깃헙계정입력 -> finish
      -> advanced -> add all branches spec -> finish -> save
       <pull 설정>
        - 녹색화살표에 우클릭 Configure Fetch 선택, change 주소, 계정 입력->
        finish -> advanced 선택 -> finish -> save and push

       
	<테스트>
       Git.java 고치고 git staging에서 commit and push


	<확인... >
	수업중에 진행하는 jsp 프로젝트를 github에 올리기
	1. github에 리모트 저장소 생성: jsp
	2. 이클립스에 있는 jsp 프로젝트를 github이랑 연동하기
	   2-1) .gitignore 먼저 생성 -------->> ★★★★★★★★★★


[이클립스에서 깃허브 Import하기(선생님이 알려주신 방법)]
Import -> Projects from Git -> Clone URI -> master체크 -> 디렉토리를 워크스페이스로
-> 3번째 체크(Import as general project) -> finish

프로젝트 우클릭 -> Configure -> Convert to Maven Project




======================================[0801]======================================

[JSP] --> Java Server Pages.. 
          Servlet이 Java Code안에 HTML이 포함되는 불편이 있어,
          이를 줄이기 위해 나온것이 JSP(HTML안에 Java Code)이다.

ㅁ webapp폴더가 root폴더가 된다.
   - localhost:8081/jsp/hello.jsp
ㅁ <% %> 안에서 java코드를 작성할 수 있다.
   - jsp에서는 Ctrl+1로 import할 수 없으니 코드를 작성하며 Ctrl+Space로 자동완성
     하며 자동으로 import시키는 것이 좋다.
     <%
	  Date dt = new Date();
	  SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
     %>
ㅁ 출력하기
       hello.jsp : <%=sdf.format(dt)%>

ㅁ page Directive(지시자)
	<%@page import="java.text.SimpleDateFormat"%>
	<%@page import="java.util.Date"%>

ㅁ 스크립틀릿(자바코드 작성)
	<%
		Date dt = new Date();
		SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
	%>

ㅁ 표현식: 값을 출력한다 --> <%=표현할 데이터 %>
	<%=sdf.format(dt)%>

ㅁ 주석
	<%-- 주석 --%>

ㅁ servlet ≒ jsp (jsp는 servlet으로 변환됨)

ㅁ 구구단 출력하기
	<table border="1">
		<%for(int i = 1; i <= 9; i++) { %>
			<tr>
				<%for(int j = 2; j <= 9; j++) { %>
					<td><%=j %> * <%=i %> = <%=j*i %></td>
				<%} %>
			</tr>
		<%} %>
	</table>

ㅁ 선언부(메소드, 변수를 선언) --> 디렉티브 바로 아래, DOCTYPE 바로 위
	<%!
		public int factorial(int fac) {
			return 0;
		}
	%>

ㅁ 메모이제이션: 메모이제이션(memoization)은 컴퓨터 프로그램이 동일한 계산을
                 반복해야 할 때, 이전에 계산한 값을 메모리에 저장함으로써 동일한
                 계산의 반복 수행을 제거하여 프로그램 실행 속도를 빠르게 하는
                 기술이다. 동적 계획법의 핵심이 되는 기술이다.

ㅁ 파라미터 가져오기
   - 한개  : request.getParameter(); --> 주로 사용
   - 여러개: request.getParameterValues(); --> 하나의 name에 여러개의 값이 있을 때
   - 맵    : request.getParameterMap(); --> 모든 파라미터를 담은 map 객체
                                            키를 모를 때 사용..(.ketSet())
   - 이름만: request.getParameterNames; --> name만 가져옴





======================================[0802]======================================

ㅁ UTF-8 설정하기: form을 사용할 때 설정하지 않으면 파라미터 한글이 깨짐
   - Get방식 UTF-8설정:
	> server.xml에 URIEncoding="utf-8"속성 추가하기(port 적는 위치)
   - Post방식 UTF-8설정: 
	> 파라미터를 받는 페이지에 <% request.setCharacterEncoding("utf-8"); %> 추가

ㅁ JSON(JavaScript Object Notation)
   - jsp파일을 생성하고 아래와 같이 contentType을 수정한다.(HTML은 지운다.)
	<%@ page language="java" contentType="application/json; charset=UTF-8"
   	    pageEncoding="UTF-8"%>

ㅁ Redirect: 클라이언트에게 다른 주소로 재 요청 하라고 응답
   Request Dispatch: 요청을 받아 다른 jsp로 위임
                     --> 서블릿으로 응답받고, jsp로 만들어줌

ㅁ servlet 생성하기
   위자드 - Servlet -> 
   패키지명: kr.or.ddit.servlet / 클래스명: RedirectServlet -> Finish

ㅁ dispatch방식 ==> servlet.RedirectServlet.java 참조
   1. 웹브라우저 주소줄에 다음 url 입력 후 엔터
      url: http://localhost:8081/redirectServlet
   2. was(tomcat)이 /redirectServlet url을 처리해줄 수 있는 servlet을 찾는다.
      mapping
          1) web.xml
          2) @WebServlet
   3. 찾은 Servlet의 service메소드를 호출
   4. service메소드에서는 요청한 객체의 메소드에 따라(request.getMethod)
      doXXX(request, response)메소드를 호출
      ** 위 예제의 경우 웹브라우저 주소줄에 url을 입력했기 때문에 GET요청이 되고
         doGet메소드가 호출된다.
   5. Servlet이 직접 응답을 생성하는것이 아니라 화면 생성을 담당하는 jsp파일에게
      요청 위임

ㅁ java 웹 개발 --> 요청처리: model1, model2
   - model1: 요청을 jsp가 받는 경우
	> 초기 개발시 속도가 빠름
	> 유지보수시 문제 발생(코드 중복, 재사용이 힘듦)
   - model2: 요청을 servlet이 받는 경우(servlet -> jsp 위임)

ㅁ 연습문제 - 파라미터 받기 연습
   - 두 개의 숫자 파라미터를 입력받아 두 숫자 사이의 모든 숫자의 합을 구하는 jsp
   - localhost:8081/jsp/jsp/sumJsp?number=1&number2=10
     화면에 1 ~ 10까지 사이에 있는 모든 숫자의 합을 화면 출력
     * number파라미터는 number2 파라미터보다 항상 작다고 가정
     result: 합의 결과
	==> requestSign.jsp, signResult.jsp





======================================[0805]======================================

[복습]
ㅁ 페이지를 이동할 때
   - Redirect: 
	=> 클라이언트가 최초 요청
	=> 서버가 클라이언트에게 다른 주소로 재 요청 하라고 응답
	=> 클라이언트가 Redirect 정보를 바탕으로 재요청
	=> 요청 2번
   - Forward(Request Dispatch): 
	=> 클라이언트가 최초 요청
	=> Request Dispatch 서버내에서 요청 위임
	=> 클라이언트 입장에서는 최초 요청에 대한 응답받음
	=> 요청 1번

ㅁ 요청처리
   - model1: 요청을 jsp가 받음
   - model2: 요청을 servlet이 받음
	> 로그인을 하기 위해 로그인 화면이 필요
	// jsp로 요청을 보내고 있음 --> model1
	localhost:8081/jsp/login.jsp
	
	// servlet으로 요청을 보내도록 수정 --> model2
	localhost:8081/jsp/login  (get)
	
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

[로그인 model2 방식 구현] ==> kr.or.ddit.login.web.LoginController.java (servlet파일)
			  ==> webapp/login/login.jsp (jsp파일)
1. 로그인 화면 요청(get)
   - login.jsp로 이동
   - 서버상태 변경 없음
   - 단순히 jsp로 위임만 하면 됨 -> forward가 적절
2. 로그인 요청(post) ==> 만약 get방식으로 사용하게 된다면 servlet파일을 한개 더 생성
   - 사용자가 ID, PW 입력

ㅁ 콘솔창 포커스 없애기
   - 프리퍼런스 - Console검색 - Show when~ 두개 체크해제

ㅁ css 부트스트랩 -> http://bootstrapk.com/
   - 다운받고 알집푼다음 폴더명을 bootstrap으로 변경하여 webapp안에 넣어준다.

ㅁ 스코프의 종류 및 특성
   - page: jsp 페이지 내에서만 공유되는 영역
	==> ≒ java의 지역변수(if, for block)
   - request: 클라이언트의 요청정보가 유지되는 동안 공유되는 영역(dispatch)
	==> ≒ java의 지역변수
   - ???: 
   - ???: 2-5ppt보고 적자..

ㅁ 개발자도구 - Application탭 - Cookies에 세션아이디가 나온다.
   - 서버에서 해당 쿠키에 대한 정보를 30분마다 지운다(기본값)

ㅁ 속성관련 메소드
   - .setAttribute()





======================================[0806]======================================

ㅁ 유저리스트 페이지
1. main 화면 사용자 리스트 클릭
   - localhost:8081/userList

2. UserListController
   - doGet
	> userDao 사용자 리스트 조회
	> request 객체에 사용자 리스트 정보를 저장
	> userList.jsp를 통해서 화면응답을 생성하도록 위임

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

ㅁ mybatis ==> http://www.mybatis.org/mybatis-3/ko/index.html
     (새로만드는 문서에서는 굳이 ibatis를 사용할 필요 없이 mybatis로 생성하자)

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

   ■ 마이바티스를 사용하기 위해 mybatis-x.x.x.jar 파일을 클래스패스에 두어야 한다.
      메이븐을 사용한다면 pom.xml에 다음의 설정을 추가하자.
<dependency>
	<groupId>org.mybatis</groupId>
	<artifactId>mybatis</artifactId>
	<version>3.5.2</version>
</dependency>

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

   ■ XML에서 SqlSessionFactory 빌드하기 ==> main/resources/kr/or/ddit/config/mybatis
						에 mybatis-config.xml 파일
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE configuration
  PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
  "http://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>
	<properties resource="kr/or/ddit/config/mybatis/db.properties"></properties>
	
	<typeAliases>
		<typeAlias alias="userVo" type="kr.or.ddit.user.model.UserVo"/>
	</typeAliases>
	
	<environments default="development">
		<environment id="development">
			<transactionManager type="JDBC" />
			<dataSource type="POOLED">
				<property name="driver" value="${jdbc.driver}" />
				<property name="url" value="${jdbc.url}" />
				<property name="username" value="${jdbc.user}" />
				<property name="password" value="${jdbc.pass}" />
			</dataSource>
		</environment>
	</environments>
	
	<mappers>
		<mapper resource="kr/or/ddit/config/mybatis/mapper/user.xml" />
	</mappers>
	
</configuration>

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

   ■ db.properties ==> main/resources/kr/or/ddit/config/mybatis
			에 db.properties 파일
jdbc.driver=oracle.jdbc.driver.OracleDriver
jdbc.url=jdbc:oracle:thin:@localhost:1521:XE
jdbc.user=JMS
jdbc.pass=java

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

   ■ MybatisUtil.java ==> main/java/kr.or.ddit.util
package kr.or.ddit.util;

import java.io.IOException;
import java.io.InputStream;

import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;

public class MybatisUtil {

	private static SqlSessionFactory factory;
	
	static {
		String resource = "kr/or/ddit/config/mybatis/mybatis-config.xml";
		try {
			InputStream inputStream = Resources.getResourceAsStream(resource);
			factory = new SqlSessionFactoryBuilder().build(inputStream);
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
	
	public static SqlSession getSession() {
		return factory.openSession();
	}
} 

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

   ■ user.xml ==> /jsp/src/main/resources/kr/or/ddit/config/mybatis/mapper/user.xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
  PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
  "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="org.mybatis.example.BlogMapper">
	<select id="getUserList" resultType="userVo">
		select * 
		  from users
	</select>
</mapper>

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

   ■ db 등록 ==> user scheme.sql ( /res에 있음 )
	- 테이블 생성: 1~27번째 줄 실행
	- 데이터 추가: 33~37번째 줄
	- 비밀번호 업뎃: update users set pass = userid || '1234';

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

   ■ UserDao
	public List<UserVo> getUserList() {
		SqlSession sqlSession = MybatisUtil.getSession();
		List<UserVo> userList = sqlSession.selectList("user.getUserList");
		sqlSession.close(); // 안닫으면 계속된 요청이 있을 때 커넥션객체를 모두 소모하여 응답이 안돌아온다.
		
		return userList;
	}

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

   ■ 톰캣에 ojdbc넣기
	- pom.xml
<dependency>
	<groupId>com.oracle</groupId>
	<artifactId>ojdbc6</artifactId>
	<version>12.1.0.2</version>
	<scope>provided</scope> <!-- 제공되어진다.. 컴파일에서만 -->
</dependency>

	- provided이므로 톰캣의 lib폴더에 jar파일을
	E:\B_Util\5.ApacheTomcat\apache-tomcat-7.0.73\lib에 넣어주기
	(.m2 폴더에 존재하는 jar파일)

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

ㅁ TDD의 목표: 잘 동작하는 깔끔한 코드

   userDao -> 테스트 코드
	1. userDao 생성
	2. userDao를 테스트할 수 있는 테스트 코드를 나중에 작성
   TDD
	1. userDao를 테스트할 수 있는 테스트 코드를 먼저 작성
	2. userDao 생성

ㅁ JUnit
 wizard -> JUnit Test Case -> name: UserDaoTest -> Finish





======================================[0807]======================================

ㅁ
localhost/scopeTest(get)
   --> input이 4개가 있는 view를 응답으로 생성

view 3개의 input에 값을 입력 후 submit(post)
   - request: brown
   - session: sally
   - application: cony
	==> scope에는 page라는 스코프가 더 있지만 걔는 servlet에서 사용할 수 없고
            jsp에서만 사용되며 잘 안쓴다.

localhost/scopeTest(post)
3가지 값을 각 영역 속성으로 저장
속성데이터를 출력할 수 있는 scopeResult.jsp forward

ㅁ 동일(==): 같은 메모리 공간에 있는 객체냐.. (동일이면 동치이다)
   ex) UserVo userVo = new UserVo();
       UserVo userVo2 = userVo;

       if(userVo == userVo2) ==> true

ㅁ 동치(equals)
   ex) UserVo userVo = new UserVo("brown");
       UserVo userVo2 = new UserVo("brown");


ㅁ JSP 기본객체(스코프 4개..)
   - request
   - session
   - application --> 더 다뤄보기 (webapp/jsp/application.jsp)

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

1. HttpServlet 상속
2. tomcat 기동
url -> init() -> service()

 String method = request.getMethod();

 service() {
     if(method.equals(GET_METHOD))
	 doGet();
     else if(method.equals(POST_METHOD))
	 doPost();
 }

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

ㅁ url의 리소스를 이용하여 디스크의 물리적 위치를 확인
   - /css/blog.css --> 물리적인 경로를 구해주는 메소드
     application.getRealPath("/css/blog.css");
	결과값: E:\A_TeachingMaterial\7.JspSpring\workspace\.metadata\.plugins
		   \org.eclipse.wst.server.core\tmp0\wtpwebapps\jsp\css\blog.css

ㅁ jsp에서 out.~를(out객체) 사용하기 위해 jsp dependency 추가
<dependency>
  <groupId>javax.servlet.jsp</groupId>
  <artifactId>javax.servlet.jsp-api</artifactId>
  <version>2.2.1</version>
  <scope>provided</scope> <!-- tomcat에서 배포해주므로 나만 사용하기 위해 배포x -->
</dependency>





======================================[0808]======================================

ㅁ Jsp불러오기.. ==> Header, Left Category등.. 한 파일로 하기
   - 지시자에 <%@ include file="/commonJsp/basicLib.jsp" %> ==> jsp파일 추가하기

ㅁ 에러처리: 3가지 방법
   - 지시자 사용: 거의 사용하지 않는 방법.. 
	jsp 가장 상단의 <%@ %>안에 errorPage="/error/page.jsp" 넣기

   - 예외 타입별 설정: WEB-INF - web.xml에 아래 코드 넣기
	  <error-page>
	  	<exception-type>java.lang.ArithmeticException</exception-type>
	  	<location>/error/type/arithmeticException.jsp</location>
	  </error-page>

   - 응답 상태 코드별 설정: WEB-INF - web.xml에 아래 코드 넣기 ==> 주로 사용
	  <error-page>
		<error-code>404</error-code>
		<location>/error/404/404.html</location>
	  </error-page>

ㅁ 에러에 대한 우선순위: 
	지시자 > 예외 타입별 > 응답 상태 코드별 > 기본 에러 페이지

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

ㅁ 달력만들기 - sql developer
--년월값을 파라미터로 받는다 "201908"
--sql select 결과는 해당 년월의 달력을 만들어주는 쿼리

--level은 1부터 시작
select add_months(to_date('201902', 'yyyyMM'), 1) - to_date('201902', 'yyyyMM')
from dual;

--d : 1 일요일, 2 월요일, 3 화요일.....7 토요일
select iw, min(sun), min(mon), min(tue), min(wed), min(thu), min(fri), min(sat)
from
(select dt, --to_char(dt, 'w') w,
        --to_char(dt, 'ww') ww,
        --to_char(dt, 'iw') iw,
        decode(to_char(dt, 'd'), 1, to_char(dt, 'iw')+1, to_char(dt, 'iw')) iw,
        to_char(dt, 'd') d,
        decode(to_char(dt, 'd'), 1, dt) sun, 
        decode(to_char(dt, 'd'), 2, dt) mon, 
        decode(to_char(dt, 'd'), 3, dt) tue, 
        decode(to_char(dt, 'd'), 4, dt) wed, 
        decode(to_char(dt, 'd'), 5, dt) thu, 
        decode(to_char(dt, 'd'), 6, dt) fri, 
        decode(to_char(dt, 'd'), 7, dt) sat
 from 
(select level, to_date('201910', 'yyyyMM') + (level-1) dt --날짜타입 + 정수 : 일자연산
from dual
connect by level <= add_months(to_date('201910', 'yyyyMM'), 1) - to_date('201910', 'yyyyMM')))
group by iw
order by iw;

--add_months(to_date('201910', 'yyyyMM'), 1) - to_date('201910', 'yyyyMM'))


select iw, min(sun), min(mon), min(tue), min(wed), min(thu), min(fri), min(sat)
from
(select dt, 
        decode(to_char(dt, 'd'), 1, to_char(dt, 'iw')+1, to_char(dt, 'iw')) iw,
        to_char(dt, 'd') d,
        decode(to_char(dt, 'd'), 1, dt) sun, 
        decode(to_char(dt, 'd'), 2, dt) mon, 
        decode(to_char(dt, 'd'), 3, dt) tue, 
        decode(to_char(dt, 'd'), 4, dt) wed, 
        decode(to_char(dt, 'd'), 5, dt) thu, 
        decode(to_char(dt, 'd'), 6, dt) fri, 
        decode(to_char(dt, 'd'), 7, dt) sat
 from 
(select level, to_date('201910', 'yyyyMM') - to_number(to_char(to_date('201910', 'yyyyMM'), 'd')) + level dt --날짜타입 + 정수 : 일자연산
from dual
connect by level <= add_months(to_date('201910', 'yyyyMM'), 1)-1 +(7-to_char(add_months(to_date('201910', 'yyyyMM'), 1)-1, 'd'))
     - (to_date('201910', 'yyyyMM') - to_char(to_date('201910', 'yyyyMM'), 'd'))))
group by iw
order by iw;


select (to_date('201910', 'yyyyMM') - to_char(to_date('201910', 'yyyyMM'), 'd')) s,
    add_months(to_date('201910', 'yyyyMM'), 1)-1 +(7-to_char(add_months(to_date('201910', 'yyyyMM'), 1)-1, 'd'))t,

add_months(to_date('201910', 'yyyyMM'), 1)-1 +(7-to_char(add_months(to_date('201910', 'yyyyMM'), 1)-1, 'd'))
     - (to_date('201910', 'yyyyMM') - to_char(to_date('201910', 'yyyyMM'), 'd')) ts
from dual;





======================================[0809]======================================

ㅁ 웹 어플리케이션 상태 유지
   - TCP 연결성: 
   - HTTP 비연결성: 요청시 연결, 응답 후 연결종료

   - cookie: 브라우저(클라이언트)에 저장되며 보안에 취약(클라이언트가 임의조작가능)
           알파벳, 숫자외에는 인코딩해줘야 한다.
   - session: was에 저장되며 서버내 로직으로 제어되므로 cookie보다 안전

   - 쿠키에 등록할 때 한글로 변환
	==> encodeURIComponent("한글");
	==> 결과: "%ED%95%9C%EA%B8%80"
   - 변환한 문자를 한글로 변환
	==> decodeURIComponent("%ED%95%9C%EA%B8%80");
	==> 결과: "한글"

ㅁ Cookies API
   - <script src="${pageContext.request.contextPath }/js/js.cookie.js"></script>
   - Cookies.get('userId');
   - Cookies.set("userId", $("#userId").val(), {expires : 30});
   - Cookies.remove("userId");





======================================[0812]======================================

ㅁ .serialize(): 전송했을 때 전송되는 파라미터를 확인할 수 있다.
	ex) $('#frm').serialize() ==> "userId=brown&pass=&rememberMe=remember-me"

ㅁ input type="checkbox": 체크가 되어 있어야만 파라미터로 전송된다.
			  (name은 당연히 필요)

ㅁ Refactor - Extract Method: 선택한 부분을 메서드로 빼서 생성한다.

ㅁ 신규시스템 구축 프로젝트 / 기존 시스템 리뉴얼    

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

ㅁ 데이터베이스 프로그래밍
   - db connection(pool): 커넥션객체는 자원이 많이 든다. 닫지 않으면 개손해
   - Apache Commons DBCP 2.7.0
	<!-- commons-dbcp2 -->
	<dependency>
	    <groupId>org.apache.commons</groupId>
	    <artifactId>commons-dbcp2</artifactId>
	    <version>2.7.0</version>
	</dependency>
   - 서블릿 만들고 @WebServlet에 아래 내용 추가 
	==> @WebServlet(urlPatterns = "/DbcpServlet", loadOnStartup = 1)
	==> loadOnStartup 속성 설정에 의해 DbcpServlet으로 최초 요청이
	    오지 않더라도 서버가 기동되는 과정에서 init메소드 호출이 이루어진다.
   - servlet application(servletContext) 얻어오기
	> jsp    : application /       session        / request / pageContext(page)
	> servlet:   ???????   / request.getSession() / request / N/A
	> ServletContext application = getServletContext();

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

ㅁ EL(Expression Language): 표현언어 ==> ★ 실무에서도 사용 ★
   - java ee의 표준 스펙 중 한가지
   - jsp2.0버전부터 안내되는 규약(spec)
   - 표현식을 보다 쉽고 간결하게 사용할 수 있는 표현방법
	<% User s_user = (User)session.getAttribute("S_USERVO"); %>
	<p> 표현식: <%=s_user.getUserNm() %> </p>  <!-- 기존 방법 -->

	<p> el(method): ${S_USERVO.getUserNm()} </p> <!-- 메서드 이용 -->

	<p> el(field): ${S_USERVO.userNm} </p> ==> ★ 주로 사용.. (필드명으로 호출)

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

ㅁ JSTL(Scriptlet)
   - JSP Standard Tag Library: 커스텀 태그 중 많이 사용되는 것을 모아서 만든 스펙
   - JSP는 디자이너와 개발자가 같이 보는 일이 생긴다.
   - 스크립틀릿 코드는 개발자를 위한 코드 -> 개발직군이 아닌 사람들에겐 낮선환경
   - 개발자 입장에서도 간결한 코드 사용이 가능 -> 코드 reading
   - 여러 언어로 서비스 하는 경우의 국제화 처리
   - 지역별 통화, 날짜 포맷

   - dependency
	<!-- jstl -->
	<dependency>
	    <groupId>javax.servlet</groupId>
	    <artifactId>jstl</artifactId>
	    <version>1.2</version>
	</dependency>

   - 사용하기(스크립틀릿)
	<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
	==> <c: 를 쓰면 자동완성 됨


	ex)
	<%
		List<User> userList = (List<User>) request.getAttribute("userList");
		for (User userVo : userList) {
	%>
		<tr>
		<td><%=userVo.getUserId()%></td>
		<td><%=userVo.getUserNm()%></td>
		<td></td>
		<td></td>
		</tr>
	<%
		}
	%>

   - 사용하기(JSTL + EL)
	ex)
	<c:forEach items="${userList}" var="userVo">
		<tr>
		<td>${userVo.userId}</td>
		<td>${userVo.userNm}</td>
		<td></td>
		<td></td>
		</tr>
	</c:forEach>





======================================[0819]======================================

ㅁ 사용자 상세화면 구현
   - 사용자 리스트 페이지에서 해당 row(tr) - 사용자 정보를 클릭했을 때
	> 사용자 아이디를 확인할 수 있는 방법
	$(".userTr").on("click", function() {
		// 클릭된 tr태그의 자식태그(td)중 첫번째 자식의 텍스트 문자열
		console.log($(this).children().first().text());
	});

	> 사용자 아이디를 파라미터로 전달

	> 사용자 상세정보 조회 - request scope 사용자 정보 설정 - jsp 화면에 출력

   - 해당 사용자의 상세 정보를 화면에 보이는 상세페이지 개발

ㅁ 제품 상세화면 구현
   - 제품 그룹 리스트에서 특정 제품 그룹 클릭 시
	> /prodList url로 요청(필요시 파라미터 보낼 것)
	> webapp/prod(임의폴더 상관x)/prodList.jsp 조회된 제품 리스트를 출력
	  ==> 제품그룹명, 제품그룹번호(P101), 바이어 이름,
                 제품아이디, 제품명, 가격(prod_price)
	  ==> ex) 컴퓨터 제품, P101, 삼성컴퓨터,
		     P101000003, 모니터 삼성전자19인치칼라, 290000
	> dao 테스트 코드 작성

ㅁ 게시판 과제
   - 게시글 작성
	> 글번호
	> 내용
   - 게시글 첨부파일 ==> service로..
	> 첨부파일번호
	> 게시글 글번호(FK)
	> 첨부파일 경로

ㅁ 트랜잭션: 여러 단계의 과정을 하나의 작업 행위로 묶는 단위
   - ex) 송금(출금 + 입금)

ㅁ junit 테스트 메소드 실행 순서
   - @Before -> @Test -> @After
   - @Test 테[스트 메소드가 실행되기 전에 @Before이 적용된 메소드를 먼저
     실행되고, @Test 메소드 실행된다.
   - @After이 적용된 메소드를 실행한다.
   - @Test 메소드는 실행순서가 보장되지 않는다.

   @Before 
   public void setup() { } // 테스트에 공통적으로 필요한 자원을 생성 / 초기화

   @After
   public void tearDown() { } // 테스트에 공통적으로 필요한 자원을 해제





======================================[0820]======================================

ㅁ JSTL: 커스텀 태그 중 많이 사용되는 것을 모아 만든 스펙
	<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>

   - 	<c:set var="code" value="01"/> --> 정의
     	${code} --> 사용

   - 	<c:if test="${code == '01'}">
		code is 01
	</c:if>

   -	<c:choose>
		<c:when test="${code == '01' }">
			code is 01
		</c:when>
		<c:when test="${code == '02' }">
			code is 02
		</c:when>
		<c:otherwise>
			code is otherwise
		</c:otherwise>
	</c:choose>

   -	<c:forEach begin="0" end="10" var="i" step="2">
		${i } <br>
	</c:forEach>

   -	<c:forEach items="${userList}" var="user" varStatus="loop">
		<!-- count가 10이하일 때만 출력되도록(데이터가 10건만) -->
		<c:if test="${loop.count <= 10 }">
			index: ${loop.index } / count: ${loop.count } /
			${user.userNm } / ${user.userId } <br>
		</c:if>
	</c:forEach>

   -	<c:forEach items="${user }" var="entry">
		${entry.key } / ${entry.value } <br>
	</c:forEach>

ㅁ html태그에 태그 저장하기
   - html
	<c:forEach items="${userList}" var="user">
		<tr class="userTr" data-userId="${user.userId }">
			<input type="hidden" value="${user.userId }"/>
			<td>${user.userId}</td>
			<td>${user.userNm}</td>
			<td>${user.alias}</td>
			<td>${user.getReg_dt_fmt()}</td>
		</tr>
	</c:forEach>

   - script
	// 클릭된 tr태그의 자식태그(td)중 첫번째 자식의 텍스트 문자열
	var tdText = $(this).children().eq(1).text();
			
	// input 태그에 저장된 값 확인
	var inputValue = $(this).find("input").val();

	// data 속성으로 값(tr 태그에 저장된 값) 확인
	var dataValue = $(this).data("userid"); // ★모두 소문자로 치환됨★





======================================[0821]======================================

ㅁ 페이지
   - 페이지당 10건씩 데이터 조회 
	> 105건의 데이터: 10페이지 + 5건 ==> 11페이지
   - 100건의 데이터 ==> 10페이지
     101건의 데이터 ==> 11페이지





======================================[0822]======================================

ㅁ 제품그룹 페이징 리스트
   - url: /lprodPagingList
   - pagesize: 5건

   - 사용자 페이징 리스트와 마찬가지로 제품그룹도 페이징 처리가 된 새로운 메뉴를 개발
   - 페이지네이션, 이전페이지, 다음페이지 포함
   - dao, service 테스트코드

ㅁ CRUD중 CREATE와 UPDATE 구현할 예정
   - 사용자 페이징 리스트에 있는 사용자 등록 버튼 클릭 시
	> 사용자 등록 화면으로 이동
	  UserFormController
		doGet ==> webapp/user/userForm.jsp를 forward





======================================[0823]======================================

ㅁ 주소 api 사용
   - juso.go.kr ==> 도메인으로 신청하는 것
   - http://postcode.map.daum.net/guide ==> 무료, 키받을 필요x





======================================[0826]======================================

ㅁ 파일업로드 ==> post방식만 가능
   - form tag enctype 속성 
	> application/x-www-form-urlencoded: 파라미터 전송 시 &파라미터명=파라미터값 형태로 전송
	> multipart/form-data: 데이터를 바이너리 형식으로 전송
   - 보내는 쪽(form태그)에서 enctype="multipart/form-data"를 설정한다.
   - 받는 쪽(servlet)에서 @MultipartConfig를 설정한다.
	> maxRequestSize: 요청 최대 크기
	> maxFileSize: 파일당 최대 크기
	> @MultipartConfig(maxFileSize = 1024 * 1024 * 5, 	==> 파일당 5MB 5개만
			   maxRequestSize = 1024 * 1024 * 5 * 5)
   - request로 받은 파일은 Part파일로 생성된다.
	> Part part = request.getPart("file"); // file: input의 name

	> part.getName(): 업로드 파라미터명(input의 name속성)
	  ==> file
	> part.getContentType()
	  ==> image/png
	> part.getSize(): 업로드 파일 사이즈
	  ==> 79052
	> part.getHeader("Content-Disposition"): 파일에 대한 정보..
	  ==> form-data; name="file"; filename="1a3a8c624457cbdcf173e9a53faea8f9.png"

ㅁ 주의할 점
   1. input type = "file"
   2. form 
   	> enctype = "multipart/form-data"
	> method = "post"
   3. @MultipartConfig()

ㅁ table 수정함 
   > alter table users add(realfilename2 varchar2(200));

ㅁ 파일업로드했을 때 파일이 저장되는 경로
   > -Dwtp.deploy="E:\A_TeachingMaterial\7.JspSpring\workspace\.metadata\.plugins\org.eclipse.wst.server.core\tmp0\wtpwebapps"
   > 해당 파일을 지우면 사이트에서 보이지 않음.. ==> 서버재시작하면 다시 보내줌(안되면 clean)





======================================[0827]======================================

ㅁ 사용자 수정 기능 개발
   - controller class
	> 화면요청
	> 사용자 정보 업데이트 요청

   - service method
	> test code 작성

   - dao method
	> test code 작성

   - sql 작성

   - 화면(view)

   ** 파일은 업데이트 개념이 없음 --> 삭제 후 신규입력

   - 요구조건
	> 사용자 아이디는 수정 불가
	> 사용자 수정화면에 현재 저장되어 있는 사용자 사진을 띄워준다(상세보기 화면)
	> 기존 사진을 업데이트하는 경우 e:upload폴더에 있는 기존 파일은 남겨둔채로 작업
	> mybatis 사용시 파라미터가 null일 때..
	<insert id="insertUser" parameterType="user">
		insert into users(userId, realfilepath)
			values(#{userId}, #{realfilepath, jdbcType=VARCHAR})
	</insert>		// realfilepath가 널이더라도 들어가게 함

ㅁ 암호화 ==> https://seed.kisa.or.kr/kisa/index.do
	  ==> res폴더안에 파일만 저장함, kisa의 알고리즘을 일부 수정함
   - 해시함수: 복호화가 안되는 암호(암호문의 결과 일부를 잘라서 이용하므로)
	==> 단방향 암호화 ==> sha256

   - 블록암호: 복호화 가능한 암호
	==> 양방향 암호화 ==> aria, seed



























